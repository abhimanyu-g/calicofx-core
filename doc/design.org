#+TITLE: calico-fx design

* Goal
Design a guitar effects processing software that is based on server-client mechanism. This software would run on an embedded board and may use the Neural network on the device to generate realistic processing effect. Here is an overview of what I am looking to implement
- Support lv2 plugins (at least in v1.0)
- Pipewire backend for all audio routing needs
- Support Bluetooth overlay for backing track support
- Front-end has a web interface to interact with the core application
  #+begin_src plantuml :file /tmp/calicofx-design-overview.png :results output
    @startuml
    [Frontend UI] as ui
    [Calicofx core] as core
    [Pipewire daemon] as pw
    [LV2 plugins] as lv2

    ui <--> core : websockets
    core <--> pw : pipewire-APIs
    core --> lv2 : lilv2-APIs
    @enduml
  #+end_src

* Operation
During operation, each /lv2 plugin/ instance is wrapped with /Pipewire client/ and connected with /Pipewire daemon/. [[https://pipewire.org/][Pipewire]] is a low-latency multimedia handling framework in Linux that is aimed to replace [[https://jackaudio.org/][JACK]] and [[https://www.freedesktop.org/wiki/Software/PulseAudio/][pulse-audio]] for audio routing.

The user controls the software with web-ui (for now) over websockets and controls
- Routing(a.k.a Linking)
- Addition/Deletion
- Update parameters

In operation, the graph might look something like this
#+begin_src plantuml :file /tmp/calicofx-flow-graph.png :results output
  @startuml
  [Audio source] as in
  [Audio sink] as out
  [Pipewire Daemon] as pw
  [BT (A2DP) Audio Sink] as bt
  [pw-client + fx-1] as fx1
  [pw-client + fx-2] as fx2
  [pw-client + fx-3] as fx3
  [pw-client + fx-4] as fx4

  in -> pw
  pw -> out
  bt --> pw
  fx1 -up--> pw
  fx2 -up--> pw
  fx3 -up--> pw
  fx4 -up--> pw
  @enduml
#+end_src

Note that,
- "pw client + fx 'x'" Implies lv2 effect wrapped inside pipewire-client
- Each effect need not be strictly connected to the previous effect as shown in the diagram, since I follow a graph based routing, node linking is up-to the user's configuration

* Class Diagram
** Overview
The overall class structure looks something like below. We enforce /pipewire/ as the media manager but the plugins although is /lv2/ now, can change in the future to support more plugin types. Hence, the plugins are abstracted
#+begin_src plantuml :file /tmp/calicofx-overview-class-dig.png :noweb yes
  @startuml
  class "SessionMgr" as mgr
  class "PipewireClient" as pw
  abstract class "PluginBase" as base
  class "LV2Manager" as lv2

  mgr .right.> pw
  pw .right.> base
  base <|.. lv2:implements

  @enduml
#+end_src

** session-manager
Session manager is responsible to
- Add/Remove new pw-clients as nodes
- Access stored nodes for params changes
- Link/unlink between multiple nodes/pw-clients
- Save and restore session ( > v1.0)

#+name: SessionMgr
#+begin_src plantuml :file /tmp/calicofx-session-mgr-class-dig.png
  @startuml
  enum ipcCommand{
        CALICOFX_ADD_NODE
        CALICOFX_UPDATE_PARAM
  }
  class SessionMgr{
        -clientMap <string uuid, Client pw-client>
        -string generateUUID (void)
        +string sessionAddNode(string uri)
        +int sessionRemoveNode(string uuid)
        +int sessionUpdateNodeParam(int paramIdx, float val)
        +int sessionLinkPort(string srcNodeUUID, int srcPortIdx, string dstNodeUUID, int dstPortIdx)
        +int sessionUnlinkNode(string srcNodeUUID, int srcPortIdx, string dstNodeUUID, int dstPortIdx)
  }
  @enduml
#+end_src

** pw-client
#+name: PipewireClient
#+begin_src plantuml :file /tmp/calicofx-pw-client-class-dig.png
  @startuml
  enum pluginType{
        PLUGIN_TYPE_LV2
  }
  class PipewireClient{
        -struct pw_thread_loop *loop
        -struct pw_filter *filter
        -PluginBase *pluginMgr
        +int pwInitClient(string uri, enum pluginType pluginType)
        +int pwUpdateClientParam(int clientPortIdx, float value)
  }
  @enduml
#+end_src

** Plugin Base
Plugin base is an abstract class which provides the interface to pipewire client class. This helps to interface various plugin types (vst, ladspa, clap...).
For the v1.0, we would be supporting only /lv2/ type plugins

This class would solely be controlled by [[*pw-client][pw-client]]. Hence, there is an instance of /Plugin base/ for every instance of /pw-client/
#+begin_src plantuml :file /tmp/calicofx-plugin-base-class-dig.png :exports results
  @startuml
  struct portDesc{
  	string label
  	uint8_t index
  }

  struct controlPortDesc {
  	struct portDesc portInfo
  	float def
  	float max
  	float min
  	float val
  	bool hasScalePoints
  }

  class PluginBase{
          +string pluginName
          +uint8_t nAudioInPorts
          +uint8_t nAudioOutPorts
          +uint8_t nControlPorts
  	+vector <struct portDesc> audioInPortDesc
          +vector <struct portDesc> audioOutPortDesc
          +vector <struct controlPortDesc> controlPortDesc
          +virtual int pluginInit()= 0
          +virtual int pluginActivate()= 0
          +virtual int pluginRun(int sampleRate)= 0
        +virtual int pluginUpdateParam(uint8_t idx, float val) = 0
  }
  @enduml
#+end_src
*** LV2-manager
Class responsible to manage lv2 specific operation. I.e,
- Parsing the plugins to fetch plugin description (ports, number and type of controls, metadata etc...)
- Instantiating and un-instantiating a plugin
- Run a plugin instance for every sample

#+begin_src plantuml :file /tmp/calicofx-lv2-manager-class-dig.png :exports results
  @startuml
  class LV2Manager: public PluginBase{
  	-string uri
  	-LilvNode pluginUriNode
  	-LilvNode pluginNode
  	-LilvInstance *pluginInstance
  	+int pluginInit() @override
  	+int pluginActivate() @override
  	+int pluginRun(int sampleRate) @override
        +int pluginUpdateParam(uint8_t idx, float val) @override
  }
  @enduml
#+end_src
**** ~pluginUpdateParam~
 ~pluginUpdateParam~ will internally call [[https://drobilla.net/docs/lilv/index.html#c.lilv_instance_connect_port][lilv_instance_connect_port]] from the /lilv/ library to connect a control port of the current instance to a value and update it, therefore updating the plugin instance's port value.

* Detailed flow
** Initialization
Initialization refers to the global initialization and is expected to be called *only once* during the start of the program, there is also a [[*De-initialize][de-initialize]] counterpart which does the opposite
#+begin_src plantuml :file /tmp/calicofx-initialization.png :exports results
  @startuml
  participant "calicofx-core" as core
  participant "lv2-client" as lv2

  core->lv2:Initialize plugin
  activate core
        lv2->lv2:Initalize world (a.k.a create context)
        lv2->lv2:Load all plugins
        lv2->core
  deactivate core
  @enduml
#+end_src

** Adding a node
#+begin_src plantuml :file /tmp/calicofx-adding-a-node.png :results output
  @startuml
  participant "front-end" as ui
  participant "calicofx-core" as core
  participant "session-manager" as mgr
  participant "pw-client" as pw
  participant "lv2-client" as lv2

  ui -> core : CALICOFX_ADD_NODE<uri>
  core -> mgr: create a new node
  mgr -> pw: create new pw-client
  pw -> pw: initialize pw resources
  pw -> pw: get a 'thread loop'
  pw -> lv2: populate plugin descriptor for <uri>
  activate pw
        lv2 -> lv2: populate plugin description \n(# of audio in , out and control ports,\ntheir names, types, etc...)
        lv2->pw
  deactivate pw
  pw -> pw: create a filter object
  pw -> pw: add ports to filter object
  pw -> pw: connect filter to get registered event callbacks
  pw -> pw: start loop thread
  pw -> mgr: pw-client object
  mgr -> mgr: generate uuid
  mgr -> mgr: save <uuid, pw-client>
  mgr -> core: uuid
  core -> ui: <<result, uuid>>
  @enduml
#+end_src

** Updating a control value
#+begin_src plantuml :file images/calicofx-update-control-param.png :results output
  @startuml
  participant "front-end" as ui
  participant "calicofx-core" as core
  participant "session-manager" as mgr
  participant "pw-client" as pw
  participant "lv2-client" as lv2

  ui -> core : CALICOFX_UPDATE_PARAM <plugin-uuid, ctrl_idx, val>
  core -> mgr : update parameter value
  mgr -> mgr : fetch /pw_client/ from the map
  mgr -> pw : update params (ctrl_idx, new_val)
  pw -> lv2 : update params (ctrl_idx, new_val)
  lv2 -> pw
  pw -> mgr
  mgr -> core
  core -> ui
  @enduml
#+end_src

** De-initialize
